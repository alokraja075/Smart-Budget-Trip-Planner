import { supabase } from './supabase';
import type { Database } from './supabase';
import { generateTransportOptions, generateAccommodationOptions, generateActivityOptions } from './openai';

type Quote = Database['public']['Tables']['quotes']['Row'];
type Segment = Database['public']['Tables']['segments']['Row'];
type Budget = Database['public']['Tables']['budgets']['Row'];
type Prefs = Database['public']['Tables']['prefs']['Row'];

interface OptimizationInput {
  quotes: Quote[];
  budgets: Budget[];
  prefs: Prefs;
  totalBudget: number;
  lockedSegments: Segment[];
}

export async function searchAndSeedQuotes(tripId: string): Promise<void> {
  const { data: trip } = await supabase
    .from('trips')
    .select('*')
    .eq('id', tripId)
    .single();

  if (!trip) throw new Error('Trip not found');

  console.log('Generating AI-based quotes for trip:', trip.title);

  const transportBudget = Math.floor(trip.total_budget * 0.3);
  const accommodationBudget = Math.floor(trip.total_budget * 0.4);
  const activityBudget = Math.floor(trip.total_budget * 0.3);

  try {
    const [transportOptions, accommodationOptions, activityOptions] = await Promise.all([
      generateTransportOptions(trip.origin, trip.destination, trip.start_date, transportBudget),
      generateAccommodationOptions(trip.destination, trip.start_date, trip.end_date, accommodationBudget),
      generateActivityOptions(trip.destination, trip.start_date, activityBudget),
    ]);

    const allQuotes = [
      ...transportOptions.map(q => ({
        trip_id: tripId,
        segment_id: null,
        type: 'transport' as const,
        source: q.title,
        price: q.price,
        currency: 'INR',
        duration_min: q.duration_min,
        comfort_score: q.comfort_score,
        options: { ...q.options, provider: q.provider },
      })),
      ...accommodationOptions.map(q => ({
        trip_id: tripId,
        segment_id: null,
        type: 'stay' as const,
        source: q.title,
        price: q.price,
        currency: 'INR',
        duration_min: q.duration_min,
        comfort_score: q.comfort_score,
        options: { ...q.options, provider: q.provider },
      })),
      ...activityOptions.map(q => ({
        trip_id: tripId,
        segment_id: null,
        type: 'activity' as const,
        source: q.title,
        price: q.price,
        currency: 'INR',
        duration_min: q.duration_min,
        comfort_score: q.comfort_score,
        options: { ...q.options, provider: q.provider },
      })),
    ];

    await supabase.from('quotes').delete().eq('trip_id', tripId).is('segment_id', null);

    if (allQuotes.length > 0) {
      await supabase.from('quotes').insert(allQuotes);
      console.log(`Generated ${allQuotes.length} AI-based quotes`);
    } else {
      console.warn('No quotes generated by AI');
    }
  } catch (error) {
    console.error('Error generating AI quotes:', error);
    throw new Error('Failed to generate AI recommendations. Please try again.');
  }
}

function calculateScore(
  quote: Quote,
  maxPrice: number,
  maxDuration: number,
  maxComfort: number,
  weights: Prefs
): number {
  const normalizedPrice = maxPrice > 0 ? quote.price / maxPrice : 0;
  const normalizedDuration = maxDuration > 0 ? quote.duration_min / maxDuration : 0;
  const normalizedComfort = maxComfort > 0 ? (maxComfort - quote.comfort_score) / maxComfort : 0;

  return (
    weights.weight_cost * normalizedPrice +
    weights.weight_time * normalizedDuration +
    weights.weight_comfort * normalizedComfort
  );
}

export async function optimizeItinerary(tripId: string): Promise<void> {
  const { data: trip } = await supabase
    .from('trips')
    .select('*')
    .eq('id', tripId)
    .single();

  if (!trip) throw new Error('Trip not found');

  const { data: quotes } = await supabase
    .from('quotes')
    .select('*')
    .eq('trip_id', tripId)
    .is('segment_id', null);

  const { data: budgets } = await supabase
    .from('budgets')
    .select('*')
    .eq('trip_id', tripId);

  const { data: prefs } = await supabase
    .from('prefs')
    .select('*')
    .eq('trip_id', tripId)
    .single();

  const { data: lockedSegments } = await supabase
    .from('segments')
    .select('*')
    .eq('trip_id', tripId)
    .eq('locked', true);

  if (!quotes || !prefs) throw new Error('Missing data for optimization');

  const budgetMap = new Map<string, number>();
  budgets?.forEach(b => budgetMap.set(b.category, b.cap));

  const lockedTotal = lockedSegments?.reduce((sum, s) => sum + s.price, 0) || 0;
  const remainingBudget = trip.total_budget - lockedTotal;

  const quotesByType = {
    transport: quotes.filter(q => q.type === 'transport'),
    stay: quotes.filter(q => q.type === 'stay'),
    activity: quotes.filter(q => q.type === 'activity'),
  };

  const maxPrice = Math.max(...quotes.map(q => q.price), 1);
  const maxDuration = Math.max(...quotes.map(q => q.duration_min), 1);
  const maxComfort = Math.max(...quotes.map(q => q.comfort_score), 1);

  const selectedQuotes: Quote[] = [];
  let totalSpent = 0;

  for (const [type, typeQuotes] of Object.entries(quotesByType)) {
    const categoryCap = budgetMap.get(type) || Infinity;

    const scored = typeQuotes.map(q => ({
      quote: q,
      score: calculateScore(q, maxPrice, maxDuration, maxComfort, prefs),
    }));

    scored.sort((a, b) => a.score - b.score);

    for (const { quote } of scored) {
      if (totalSpent + quote.price <= remainingBudget && quote.price <= categoryCap) {
        selectedQuotes.push(quote);
        totalSpent += quote.price;
        break;
      }
    }
  }

  await supabase.from('segments').delete().eq('trip_id', tripId).eq('locked', false);

  const startDate = new Date(trip.start_date);
  const endDate = new Date(trip.end_date);

  const segmentsToInsert = selectedQuotes.map((quote, idx) => {
    let start = new Date(startDate);
    let end = new Date(startDate);

    if (quote.type === 'transport') {
      end = new Date(start.getTime() + quote.duration_min * 60 * 1000);
    } else if (quote.type === 'stay') {
      end = new Date(endDate);
    } else if (quote.type === 'activity') {
      start = new Date(start.getTime() + 24 * 60 * 60 * 1000);
      end = new Date(start.getTime() + quote.duration_min * 60 * 1000);
    }

    return {
      trip_id: tripId,
      type: quote.type,
      title: quote.source,
      provider: quote.source,
      start_ts: start.toISOString(),
      end_ts: end.toISOString(),
      duration_min: quote.duration_min,
      comfort_score: quote.comfort_score,
      price: quote.price,
      currency: quote.currency,
      locked: false,
      status: 'selected',
      meta: quote.options,
    };
  });

  if (segmentsToInsert.length > 0) {
    await supabase.from('segments').insert(segmentsToInsert);
  }

  await supabase
    .from('trips')
    .update({ status: 'optimized', updated_at: new Date().toISOString() })
    .eq('id', tripId);
}

export async function replanImpacted(tripId: string): Promise<void> {
  const { data: events } = await supabase
    .from('events')
    .select('*')
    .eq('trip_id', tripId)
    .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString());

  if (!events || events.length === 0) {
    return;
  }

  const impactedTypes = new Set<string>();
  events.forEach(event => {
    if (event.kind === 'delay' || event.kind === 'price_change') {
      impactedTypes.add('transport');
    }
  });

  if (impactedTypes.size > 0) {
    await searchAndSeedQuotes(tripId);
    await optimizeItinerary(tripId);
  }
}
